import java.math.BigDecimal;

// 데이터 타입
public class Example04 {
    // 원시/기본 타입 : 구조가 상대적으로 단순하고 메모리에 직접 저장이 되어서 불러오기 때문에
    // 주소값 형태의 호출이 필요 없다
    // 참조 타입 : class를 기반으로 해서 객체화된 데이터 -> 주소값. -> 메서드, 값
    // 기본 타입
    public static void main(String[] args) {
        // [8개]
        // 숫자
        // - 정수형 - byte, short, **int, **long
        // - 실수형 - float, **double
        // 각각 메모리상 차지하는 '크기'
        // 불리언 (**boolean) - true/false
        // 문자 - char
        // <-> String 문자열 참조타입. <- 원시타입이 아니다
        // JS -> number, string, [undefined, null], boolean,
        //          symbol, bigint ...

        // 정수형
        // -> 특정한 숫자를 저장한다 -> 뒤에 소수점이 없다
        // -> 2진법. 0,1 => 2가 되면 다음 자리수로 넘어가기 때문에.
        // 일반적인 정수형(뒤에 아무것도 안 붙는...) <-> 실수 1.xyz... -> 추가적인 작업이 필요
        // 갯수, 데이터들은 깔끔하게 정수. counter...
        // <-> 실수형.
        // 8bit = 1byte -> bit 0,1 -> 8개의 비트면 2^8
        // 256개의 숫자를 표현할 수 있음. -> -128 ~ 127
        // signed. sign (부호) -> 음의 부호, 양의 부호.
        // 128? -> 127? 0 때문에.
        byte by = 1; // 00000000
//        byte by2 = 128; // 128을 넣을 수 없음.
        // 범위가 존재한다
        // 256, 65536 -> 에러나 해킹할 때... 게임. 최대치가 255. 65535.
        // unsigned -> 부호없이 0부터 비트의 Max 값까지 표현.
        short sh = 128; // 2^16 -> 65536 -> -32768 ~ 32767
        // byte을 앞뒤로 2개 붙임 -> 0000000000000000
//        short sh2 = 32768; // 최대값을 넘는 문제...
        int i = 32768; // 가장 표준적으로 쓰이는 '적당한 크기'의 정수 타입
        // integer.
        // 2^32. -2,147,483,648 ~ 2,147,483,647
        // 20억. -20억 ~ 20억. 10^9. 10억 단위. billion.
//        int i2 = 2147483648; // 10억까지 가는 경우가 있음?
        // 합계 연산하거나, 곱연산을 하거나, 유저가 엄청 많아서 무언가 이러한 누적값들이 클 경우
        // 알고리즘할 때 int를 넘는 경우를 가끔 만난다
        long l = 2147483648L; // L을 붙여줘야함
        // 2^64  = -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807
        // 10^18. 엄청 큰 단위...

        // 다 int, 다 long으로 해도 될까? -> 요새 컴퓨터에선 상관이 없음.
        // jvm -> 메모리를 관리 (gc) <- 예전에는 중요했는데...

        // 실수형? 0.12345. 3.141592...
        float f = 0.12345678910F; // L을 입력했던 것 처럼 f,F를 입력해서 표시해줌
        // 2^32 -> 부동소수점 -> 6~7자리수. 소수점 아래로 6~7자리.
        System.out.println(f); // 짤려서 표기
        float f2 = 12345678910.12345678910F;
        System.out.println(f2);
        double d = 0.12345678910111213141516; // 뒤에 안붙여도 된다
        double d2 = 12345678910.12345678910; // 뒤에 안붙여도 된다
        System.out.println(d); // 15~16자리
        System.out.println(d2);
        // double
        // 아무리 상세하게 해도 일반적인 숫자를 -> 이진법 기반을 나타내면 문제가 생겨요
        // 정밀하게 표현하기 위해서 BigDecimal을 쓰게 된다

        // int +-20억. long.
        // double -> BigDecimal

        boolean tt = true;
        boolean ff = false;
        // truthy, falsy가 없음 -> 무조건 boolean으로 평가를 해줘야함
        // 비어있는 배열, 객체, undefined, null 등을 false로 취급 (JS)
        // -> 여긴 무조건 비교를 하든가, 처리해주는 기능 등으로 변경해줘야한다
//        if (1) {
//
//        }
        // 조건식에다가 boolean이 아닌 값 자체를 넣을 수 없음.

        // 자바에서는 ' '가 char 용이다
        char c = 'a'; // ASCII 코드 등...
        // 97.
        char c2 = 98;
//        char c2 = 'abc';
        String s = "abc"; // " " string 용.
        char[] cArr = {'a', 'b', 'c'}; // 문자배열을 문자열 처럼 쓸 수도 있는데...
        System.out.println(cArr);
        System.out.println(c + 1); // 문자에다가 숫자를 더할 수 있음?
        System.out.println(c2);
    }
}
